[
  {
    "jobTitle": "Frontend Engineer",
    "questions": [
      {
        "question": "How do you optimize performance in a React application?",
        "category": "Performance",
        "difficulty": "Medium",
        "expectedAnswer": "A strong answer might include discussion of code splitting, memoization (useMemo, useCallback), lazy loading, and performance profiling.",
        "followUp": "Can you give a specific example from a previous project?",
        "commonMistakes": [
          "Not considering lazy loading assets.",
          "Overuse of useEffect without dependency optimization.",
          "Ignoring bundle size impact."
        ],
        "scoringRubric": {
          "5": "Comprehensive understanding, provides detailed examples, mentions trade-offs.",
          "3": "General knowledge but lacks real-world applications.",
          "1": "Only mentions basic optimizations like 'useMemo' without explanation."
        },
        "realWorldExample": "At Facebook, React engineers used code splitting with React.lazy to reduce initial load times by 30%.",
        "bestPractices": "Encourage candidates to discuss their profiling techniques and how they measure performance bottlenecks."
      },
      {
        "question": "What strategies do you use for state management?",
        "category": "Architecture",
        "difficulty": "Hard",
        "expectedAnswer": "Candidates should mention context, Redux, Zustand, or other state management libraries and explain trade-offs.",
        "followUp": "How do you decide which state management solution is best for a project?",
        "commonMistakes": [
          "Defaulting to Redux for small applications.",
          "Not considering Context API for simple state needs.",
          "Failing to discuss performance implications."
        ],
        "scoringRubric": {
          "5": "Demonstrates a deep understanding of state management options and trade-offs.",
          "3": "Mentions multiple solutions but lacks depth in comparisons.",
          "1": "Only discusses Redux without justification."
        },
        "realWorldExample": "Netflix moved from Redux to React Query for data fetching to improve efficiency and reduce boilerplate.",
        "bestPractices": "Ask candidates about real-world performance trade-offs when choosing a state management approach."
      }
    ]
  },
  {
    "jobTitle": "Backend Engineer",
    "questions": [
      {
        "question": "How do you design an API for high scalability?",
        "category": "System Design",
        "difficulty": "Hard",
        "expectedAnswer": "A good answer will discuss stateless design, load balancing, caching strategies, and database optimizations.",
        "followUp": "What challenges have you faced in scaling an API?",
        "commonMistakes": [
          "Failing to mention horizontal scaling options.",
          "Ignoring caching strategies.",
          "Overlooking API gateway optimizations."
        ],
        "scoringRubric": {
          "5": "Describes end-to-end scaling with database, caching, and load balancing optimizations.",
          "3": "Understands scaling but omits key trade-offs.",
          "1": "Only mentions 'use a load balancer' without further details."
        },
        "realWorldExample": "Uber's API is stateless and uses Redis for caching, reducing latency by 40%.",
        "bestPractices": "Encourage candidates to discuss trade-offs in scaling different types of services (monolith vs. microservices)."
      },
      {
        "question": "How do you ensure database performance under load?",
        "category": "Performance",
        "difficulty": "Medium",
        "expectedAnswer": "Expected answers include indexing strategies, query optimization, and possibly sharding or replication.",
        "followUp": "Can you share an experience where you improved database performance?",
        "commonMistakes": [
          "Relying only on indexing without considering query optimization.",
          "Over-normalizing data structures.",
          "Ignoring read vs. write workload patterns."
        ],
        "scoringRubric": {
          "5": "Explains indexing, query profiling, and real-world optimizations.",
          "3": "Mentions indexing but lacks deeper discussion of database tuning.",
          "1": "Only states 'use indexes' without explaining how."
        },
        "realWorldExample": "Airbnb improved query performance by partitioning their database and using Redis for caching frequently accessed data.",
        "bestPractices": "Look for candidates who discuss **database trade-offs** between read-heavy and write-heavy workloads."
      }
    ]
  }
]
